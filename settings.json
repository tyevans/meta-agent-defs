{
  "env": {
    "CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS": "1",
    "CLAUDE_CODE_ENABLE_TELEMETRY": "1",
    "ENABLE_TOOL_SEARCH": "auto:5",
    "OTEL_METRICS_EXPORTER": "otlp",
    "OTEL_LOGS_EXPORTER": "otlp",
    "OTEL_EXPORTER_OTLP_PROTOCOL": "grpc",
    "OTEL_EXPORTER_OTLP_ENDPOINT": "http://localhost:4317"
  },
  "permissions": {
    "allow": [
      "Bash(uv sync:*)",
      "Bash(uv run pytest:*)",
      "Bash(uv run python:*)",
      "Bash(uv run ruff:*)",
      "Bash(uv run mypy:*)",
      "Bash(docker compose:*)",
      "Bash(bd:*)",
      "Bash(git status:*)",
      "Bash(git diff:*)",
      "Bash(git log:*)",
      "Bash(git show:*)",
      "Bash(git branch:*)",
      "Bash(just:*)",
      "Bash(uv add:*)",
      "Bash(uv remove:*)",
      "Bash(git add:*)",
      "Bash(git commit:*)",
      "Bash(git push:*)",
      "Bash(git mv:*)",
      "Bash(git checkout:*)",
      "Bash(tree:*)"
    ],
    "defaultMode": "default"
  },
  "hooks": {
    "SessionStart": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "echo '=== Session Start ==='; DIRTY=$(git status --porcelain 2>/dev/null); if [ -n \"$DIRTY\" ]; then DCOUNT=$(echo \"$DIRTY\" | wc -l | tr -d ' '); echo \"Tree:    $DCOUNT uncommitted files\"; else echo 'Tree:    clean'; fi; LOGS=$(git log --oneline -3 --format='%s' 2>/dev/null | cut -c1-30 | tr '\\n' ',' | sed 's/,/, /g; s/, $//'); echo \"Last:    ${LOGS:-no commits}\"; STATS=$(bd stats 2>/dev/null); IP=$(echo \"$STATS\" | grep 'In Progress' | awk '{print $NF}'); RD=$(echo \"$STATS\" | grep 'Ready' | awk '{print $NF}'); echo \"Open:    ${IP:-0} in-progress, ${RD:-0} ready\"; if [ -f tools/git-intel/target/debug/git-intel ]; then HOT=$(tools/git-intel/target/debug/git-intel churn --repo . --limit 3 2>/dev/null | python3 -c \"import sys,json; data=json.load(sys.stdin)['files']; print(', '.join(f'{d[\\\"path\\\"].split(\\\"/\\\")[-1]}({d[\\\"commit_count\\\"]})' for d in data))\" 2>/dev/null); else HOT=$(git log --pretty=format: --name-only -10 2>/dev/null | grep -v '^$' | sort | uniq -c | sort -rn | head -3 | awk '{name=$2; split(name,a,\"/\"); print a[length(a)]\"(\"$1\")\"}' | paste -sd ',' - | sed 's/,/, /g'); fi; if [ -n \"$HOT\" ]; then echo \"Hot:     $HOT\"; fi; if [ -f .claude/team.yaml ]; then TN=$(grep '^team:' .claude/team.yaml 2>/dev/null | head -1 | sed 's/^team: *//'); MC=$(grep '^ *- name:' .claude/team.yaml 2>/dev/null | wc -l | tr -d ' '); echo \"Team:    ${TN:-unknown} ($MC members)\"; fi; if [ -n \"$DIRTY\" ]; then echo 'Next:    review uncommitted changes from previous session'; else READY_TITLE=$(bd ready --limit 1 2>/dev/null | grep '^1\\.' | sed 's/^[^:]*: //' | head -1); if [ -n \"$READY_TITLE\" ]; then echo \"Next:    $READY_TITLE\"; else echo 'Next:    backlog clear â€” create new work or explore'; fi; fi; echo '=== ==='; UNPUSHED=$(git log @{u}.. --oneline 2>/dev/null); if [ -n \"$UNPUSHED\" ]; then UPCOUNT=$(echo \"$UNPUSHED\" | wc -l | tr -d ' '); echo \"NOTE: $UPCOUNT unpushed commits\"; fi; if [ -f memory/sessions/last.md ]; then echo '--- Last Session ---'; cat memory/sessions/last.md; echo '---'; fi; bd prime 2>/dev/null || true"
          }
        ]
      }
    ],
    "PreCompact": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "bd sync --flush-only 2>/dev/null || true"
          }
        ]
      }
    ],
    "PreToolUse": [
      {
        "matcher": "Bash",
        "hooks": [
          {
            "type": "command",
            "command": "if echo \"$CLAUDE_TOOL_INPUT\" | grep -qE '\"git push' 2>/dev/null; then if [ -d .beads ]; then STATUS=$(bd sync --status 2>/dev/null); if echo \"$STATUS\" | grep -qiE 'uncommitted|dirty|pending'; then echo 'BEADS WARNING: Uncommitted beads changes detected. Run bd sync before pushing.' >&2; fi; fi; fi"
          }
        ]
      },
      {
        "matcher": "Bash",
        "hooks": [
          {
            "type": "command",
            "command": "INPUT=\"$CLAUDE_TOOL_INPUT\"; if echo \"$INPUT\" | grep -qE '\"git reset --hard' 2>/dev/null; then echo 'DESTRUCTIVE WARNING: git reset --hard will discard all uncommitted changes. This is irreversible.' >&2; elif echo \"$INPUT\" | grep -qE '\"git checkout \\.' 2>/dev/null; then echo 'DESTRUCTIVE WARNING: git checkout . will discard all unstaged changes. This is irreversible.' >&2; elif echo \"$INPUT\" | grep -qE '\"git clean -f' 2>/dev/null; then echo 'DESTRUCTIVE WARNING: git clean -f will permanently delete untracked files.' >&2; elif echo \"$INPUT\" | grep -qE '\"rm -rf [^\"]*[^/.]' 2>/dev/null; then echo 'DESTRUCTIVE WARNING: rm -rf detected on a non-trivial path. Verify the target before proceeding.' >&2; elif echo \"$INPUT\" | grep -qE '\\.beads/' 2>/dev/null && echo \"$INPUT\" | grep -qvE '\"bd ' 2>/dev/null; then echo 'DESTRUCTIVE WARNING: Direct .beads/ file operation detected. Use bd commands instead of modifying .beads/ internals directly.' >&2; fi"
          }
        ]
      }
    ],
    "PostToolUse": [
      {
        "matcher": "Task",
        "hooks": [
          {
            "type": "command",
            "command": "echo 'REVIEW GATE: Agent completed. Verify deliverable quality before proceeding:' >&2; echo '  [ ] Spike sections present: Firm Tasks Found | Areas Needing Deeper Spikes | Clean Areas | Summary' >&2; echo '  [ ] Findings tagged with confidence: CONFIRMED | LIKELY | POSSIBLE' >&2; echo '  [ ] Evidence includes file paths and line numbers' >&2; echo '  [ ] Gaps captured as new beads | Downstream connections identified' >&2"
          }
        ]
      }
    ],
    "SessionEnd": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "mkdir -p memory/sessions && NOW=$(date '+%Y-%m-%d %H:%M') && echo \"## Last Session: $NOW\" > memory/sessions/last.md && echo '' >> memory/sessions/last.md && echo '### Commits' >> memory/sessions/last.md && COMMITS=$(git log --oneline -10 2>/dev/null); if [ -n \"$COMMITS\" ]; then echo \"$COMMITS\" >> memory/sessions/last.md; else echo '(none)' >> memory/sessions/last.md; fi && echo '' >> memory/sessions/last.md && echo '### Working Tree' >> memory/sessions/last.md && TREE=$(git status --short 2>/dev/null); if [ -n \"$TREE\" ]; then echo \"$TREE\" >> memory/sessions/last.md; else echo 'clean' >> memory/sessions/last.md; fi && echo '' >> memory/sessions/last.md && echo '### Backlog' >> memory/sessions/last.md && BACKLOG=$(bd stats --oneline 2>/dev/null || bd stats 2>/dev/null); if [ -n \"$BACKLOG\" ]; then echo \"$BACKLOG\" >> memory/sessions/last.md; else echo '(beads unavailable)' >> memory/sessions/last.md; fi && echo '' >> memory/sessions/last.md && echo '### In Progress' >> memory/sessions/last.md && INPROG=$(bd list --status=in_progress 2>/dev/null); if [ -n \"$INPROG\" ]; then echo \"$INPROG\" >> memory/sessions/last.md; else echo '(none)' >> memory/sessions/last.md; fi; bd sync --flush-only 2>/dev/null || true"
          }
        ]
      }
    ]
  },
  "skipDangerousModePermissionPrompt": true,
  "effortLevel": "medium"
}
